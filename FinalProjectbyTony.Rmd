---
title: "Final Project"
author: "Shane Taylor shanemt2@illinois.edu; Zhouning Ma zm11@illinois.edu; Kevin Mackie kevindm2@illinois.edu"
date: "7/28/2019"
output: html_document
---

# The is not the final format, we should reformat/edit each section

# Group members
- Shane Taylor shanemt2@illinois.edu 
- Zhouning Ma zm11@illinois.edu 
- Kevin Mackie kevindm2@illinois.edu


# Library
```{r, warning=FALSE}
#install.packages("corrplot")
#install.packages("kableExtra")
#install.packages('caret', dependencies = TRUE)


library(GGally)
library(faraway)
library(leaps)
library(corpcor)
library(corrplot)
library(ggcorrplot)
library(knitr)
library(kableExtra)
library(caret)
library(outliers)
library(MASS)
library(faraway)
library(ggplot2)
library(ggthemes)
library(lmtest)

```

#Public method

```{r}
ptm = proc.time()
is_debug = TRUE
missing = "missing"
response  = c("SalePrice")

calc_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}

mape = function(actual, pred){
  mean(abs((actual - pred) / actual)) * 100
}

convert_factor_to_numeric = function(variable){
  result = as.numeric(variable)
  result[which(is.na(result))] = 0
  result
}

factor_preprocess = function(variable){
  level = unique(variable)
  numberoflevel = length(level)

  factor(variable, levels = level, labels = seq(1, numberoflevel))
}

start_log = function(){
  if (is_debug){
     ptm = proc.time()
  }
}

end_log = function(){
    if (is_debug){
       print(proc.time() - ptm)
    }
}

validate_data_structure = function(dataset1, dataset2){
  validate_result = TRUE 
  for (i in which(sapply(dataset2, is.factor))) {
     level1 = unique(dataset1[, i])
     level2 = unique(dataset2[, i])
      
          
     if (length(setdiff(level1, level2)) > 0){
         print(level1)
         print(level2)
         validate_result = FALSE
     }
     if (length(setdiff(level2, level1)) > 0){
         print(level2)
         print(level1)
         validate_result = FALSE
     }
  }
  validate_result
}


get_Subset_by_remove_no_existing_factors = function(test_dataset, train_dataset){
  result_dataset = test_dataset
  for (i in which(sapply(test_dataset, is.factor))) {
     train_levels = unique(train_dataset[, i])
     result_dataset = subset(result_dataset, (result_dataset[,i] %in% train_levels))
  }
  result_dataset
}



```



# Introduction
The data, which was found on Kaggle, is a publicly available data set on housing prices that was curated by Dean De Cock of Truman state university.

* https://www.kaggle.com/c/house-prices-advanced-regression-techniques/overview
* http://jse.amstat.org/v19n3/decock.pdf

It consists of 1460 observations with one numerical response (house price) and 80 predictors. The predictors are a relatively even mix of numerical and categorical variables.

Here's a brief version of what you'll find in the data description file.

- SalePrice - the property's sale price in dollars. This is the target variable that you're trying to predict.
- MSSubClass: The building class
- MSZoning: The general zoning classification
- LotFrontage: Linear feet of street connected to property
- LotArea: Lot size in square feet
- Street: Type of road access
- Alley: Type of alley access
- LotShape: General shape of property
- LandContour: Flatness of the property
- Utilities: Type of utilities available
- LotConfig: Lot configuration
- LandSlope: Slope of property
- Neighborhood: Physical locations within Ames city limits
- Condition1: Proximity to main road or railroad
- Condition2: Proximity to main road or railroad (if a second is present)
- BldgType: Type of dwelling
- HouseStyle: Style of dwelling
- OverallQual: Overall material and finish quality
- OverallCond: Overall condition rating
- YearBuilt: Original construction date
- YearRemodAdd: Remodel date
- RoofStyle: Type of roof
- RoofMatl: Roof material
- Exterior1st: Exterior covering on house
- Exterior2nd: Exterior covering on house (if more than one material)
- MasVnrType: Masonry veneer type
- MasVnrArea: Masonry veneer area in square feet
- ExterQual: Exterior material quality
- ExterCond: Present condition of the material on the exterior
- Foundation: Type of foundation
- BsmtQual: Height of the basement
- BsmtCond: General condition of the basement
- BsmtExposure: Walkout or garden level basement walls
- BsmtFinType1: Quality of basement finished area
- BsmtFinSF1: Type 1 finished square feet
- BsmtFinType2: Quality of second finished area (if present)
- BsmtFinSF2: Type 2 finished square feet
- BsmtUnfSF: Unfinished square feet of basement area
- TotalBsmtSF: Total square feet of basement area
- Heating: Type of heating
- HeatingQC: Heating quality and condition
- CentralAir: Central air conditioning
- Electrical: Electrical system
- 1stFlrSF: First Floor square feet
- 2ndFlrSF: Second floor square feet
- LowQualFinSF: Low quality finished square feet (all floors)
- GrLivArea: Above grade (ground) living area square feet
- BsmtFullBath: Basement full bathrooms
- BsmtHalfBath: Basement half bathrooms
- FullBath: Full bathrooms above grade
- HalfBath: Half baths above grade
- Bedroom: Number of bedrooms above basement level
- Kitchen: Number of kitchens
- KitchenQual: Kitchen quality
- TotRmsAbvGrd: Total rooms above grade (does not include bathrooms)
- Functional: Home functionality rating
- Fireplaces: Number of fireplaces
- FireplaceQu: Fireplace quality
- GarageType: Garage location
- GarageYrBlt: Year garage was built
- GarageFinish: Interior finish of the garage
- GarageCars: Size of garage in car capacity
- GarageArea: Size of garage in square feet
- GarageQual: Garage quality
- GarageCond: Garage condition
- PavedDrive: Paved driveway
- WoodDeckSF: Wood deck area in square feet
- OpenPorchSF: Open porch area in square feet
- EnclosedPorch: Enclosed porch area in square feet
- 3SsnPorch: Three season porch area in square feet
- ScreenPorch: Screen porch area in square feet
- PoolArea: Pool area in square feet
- PoolQC: Pool quality
- Fence: Fence quality
- MiscFeature: Miscellaneous feature not covered in other categories
- MiscVal: $Value of miscellaneous feature
- MoSold: Month Sold
- YrSold: Year Sold
- SaleType: Type of sale
- SaleCondition: Condition of sale

One of the challenges in using this data set will be model selection, as there are a huge number of predictors available. These include typical predictors for house pricing (lot frontage and size, total square footage), but many other predictors as well (type and condition of sale; specific features of the house such as whether it has a pool, central air; features of the street and neighborhood; etc.)

Our interest in this data set is that it has a reasonable number of observations and many numeric and categorical predictors. As a final project data set, it gives us a lot to work with for model selection and analysis. 

The questions we wish to answer with this data set are:

* Given the very large number of predictors available, what is the minimal set of predictors needed to produce a low rate (defined below) of prediction errors?
* What is the set of predictors that can both achieve acceptable prediction performance and provide a good explanatory model?

In short, we want to find a model that both performs well and is good for explantory purposes.

Translating the above questions into specific goals, we will perform a model selection process to identify a linear model that:

* Has a Mean Absolute Percentage Error less than 15%, and preferably 10% or lower
* Adheres to LINE assumptions for linear regression i.e. has a BP test p value of < 0.1 and/or a Shapiro-Wilk p value of < 0.1
* Has no destabilizing collinearity among the predictors i.e. no VIF >= 5



# Methods
This section should contain any information about data preparation that is performed to the original data before modelling. Then you will apply methods seen in class, which may include some of the following but are not limited to:

- Multiple linear regression
- Dummy variables
- Interaction
- Residual diagnostics
- Outlier diagnostics
- Transformations
- Polynomial regression
- Model selection
Your task is not to use as many methods as possible. Your task is to use appropriate methods to find a good model that can correctly answer a question about the dataset, and then to communicate your result effectively.


## Exploratory Data Analysis
```{r}
preprocess = function(dataset){
  datasetv1 = dataset
  for (i in which(sapply(dataset, is.numeric))) {
      datasetv1[is.na(dataset[, i]), i] = mean(dataset[, i],  na.rm = TRUE)
  }

  
  # factor preprocess
  datasetv2 = datasetv1
  for (i in which(sapply(datasetv1, is.character))) {
      datasetv2[is.na(datasetv1[, i]), i] = missing
      datasetv2[, i] = as.factor(datasetv2[, i])
  }

   #Removing outlier data points
   datasetv3 = datasetv2
   if (!is_debug){
      number_of_column = ncol(datasetv2)
      for(i in 1:number_of_column){
         if (is.numeric(datasetv3[, i])){
            outlier_tf = -1
            while (outlier_tf != 0){
               outlier_tf = outlier(datasetv3[, i])
               if (outlier_tf > 0){
                  datasetv3 = datasetv3[-outlier_tf, ]
               }
           }
        }
    }  
   }
   
   datasetv3
}


drop_only_one_level_factor = function(dataset){
  datasetv1 = dataset
  droplist = c()
  for (i in which(sapply(dataset, is.factor))) {
      level = unique(dataset[, i])
      if ((length(level) <= 1) | ((length(level) == 2) & (missing %in% level))){
          droplist = c(droplist, i)
      }
  }

  for (i in which(sapply(datasetv1, is.numeric))) {
      level = unique(datasetv1[, i])
      if (length(level) <= 1){
          droplist = c(droplist, i)
      }
  }
  datasetv1 = datasetv1[ , -droplist]
  datasetv1
}
```


```{r}
train = read.csv("train.csv", stringsAsFactors=FALSE)[, -1]
house_prices_train = preprocess(train)

```



# Test collinearity

##Correlation tests
```{r}
correlation_tests = function(data){
   drops <- c("SalePrice")
   X = data[ , !(names(data) %in% drops)]
   round(cor(X, use = "everything"), 4)
}

correlation_plot = function(corr_data){
   corrplot(corr_data, type = "upper", tl.pos = "td",
         method = "circle", tl.cex = 0.5, tl.col = 'black',
         diag = FALSE)
}

correlation_table = function(corr_data){
   kable(corr_data, "html") %>%
     kable_styling(bootstrap_options = "striped", font_size = 9) %>%
     scroll_box(width = "100%", height = "500px")
}

correlation_list = function(corr_data){
    corr_data[which(corr_data > 0.8)]
}


X_numeric = house_prices_train[sapply(house_prices_train, is.numeric)]
correlation_test_result = correlation_tests(X_numeric)
correlation_plot(correlation_test_result)
correlation_table(correlation_test_result)
correlation_list(correlation_test_result)
```






```{r, warning=FALSE}
remove_leverage_Observations = function(model, data){
     data[-which(hatvalues(model) > 2 * mean(hatvalues(model))), ]
}

remove_Outliers_Observations = function(model, data){
     data[-which(abs(rstandard(model)) > 2), ]
}

remove_Influence_Observations = function(model, data){
     data[-which(cooks.distance(model) > 4 / length(cooks.distance(model))), ]
}

remove_unusual_observations = function(model, dataset){
    dataset = remove_leverage_Observations(model, dataset)
    dataset = remove_Outliers_Observations(model, dataset)
    dataset = remove_Influence_Observations(model, dataset)
    dataset = drop_only_one_level_factor(dataset)
    dataset
}



build_additive_model = function(dataset){
    model = lm(SalePrice ~ ., data = dataset)
    model
}
```

>First of all, We will build an additive model.

```{r}
additive_model = build_additive_model(house_prices_train)
additive_model_data = remove_unusual_observations(additive_model, house_prices_train)
additive_model = build_additive_model(additive_model_data)
(vifs = vif(additive_model)[which(vif(additive_model) > 5)])

```



>Remote the predictors which VIF value greater than 5 to build the model
```{r}
build_dynamic_model = function(outcome, variables, data){
   f= as.formula(paste(outcome, paste(variables, collapse=" + "), sep=" ~ ")) 
   model = lm(f ,data) 
   model
}

# Dynamic build the model remove all the predictors which VIF value greater than 5
allpredictors = names(house_prices_train)
predictors = setdiff(allpredictors,  names(vifs)) 
predictors = setdiff(predictors, response) 
additive_modified_model = build_dynamic_model(response, predictors, house_prices_train)

additive_modified_model_data = remove_unusual_observations(additive_modified_model, house_prices_train)
allpredictors = names(additive_modified_model_data)
predictors = setdiff(allpredictors,  names(vifs)) 
predictors = setdiff(predictors, response) 
additive_modified_model = build_dynamic_model(response, predictors, additive_modified_model_data)

#(vifs = vif(additive_modified_model)[which(vif(additive_modified_model) > 5)])
```


>AIC backward to select the model
```{r}
build_model_by_AIC_Backward = function(data){
   start_log()
   start_model = lm(SalePrice ~ ., data)
   aic_backward_model = step(start_model, trace = 0)
   end_log()
   aic_backward_model
}
aic_backward_model = build_model_by_AIC_Backward(house_prices_train)

#summary(aic_backward_model)

#lm(formula = SalePrice ~ MSZoning + LotFrontage + LotArea + Street + 
##     LandContour + Utilities + LotConfig + LandSlope + Neighborhood + 
##     Condition1 + Condition2 + BldgType + HouseStyle + OverallCond + 
##     YearRemodAdd + RoofStyle + RoofMatl + Exterior1st + MasVnrType + 
##     ExterQual + BsmtQual + BsmtExposure + BsmtFinType1 + HeatingQC + 
##     BedroomAbvGr + KitchenQual + FireplaceQu + GarageFinish + 
##     GarageQual + GarageCond + PoolQC + SaleType, data = data)
```

>We will try BIC backward to select the model
```{r}
build_model_by_BIC_Backward = function(start_model, data){
   start_log()
   n = nrow(data)
   model = step(start_model, k = log(n), trace = 0)
   end_log()
   model
}
bic_backward_model = build_model_by_BIC_Backward(additive_modified_model, additive_modified_model_data)
#summary(bic_backward_model)
#(vifs = vif(bic_backward_model)[which(vif(bic_backward_model) > 5)])

## lm(formula = SalePrice ~ LotArea + Neighborhood + BldgType + 
##     OverallCond + YearRemodAdd + RoofMatl + ExterQual + BsmtQual + 
##     BsmtExposure + BedroomAbvGr + KitchenQual + FireplaceQu + 
##     GarageFinish + PoolQC, data = data)

```


>We will try response transformer model.
```{r}
bic_backward_response_transformer_model = lm(log(SalePrice) ~ LotArea + Neighborhood + BldgType + OverallCond + YearRemodAdd + RoofMatl + ExterQual + BsmtQual + BsmtExposure + 
            BedroomAbvGr + KitchenQual + FireplaceQu + GarageFinish + PoolQC, house_prices_train)
#summary(bic_backward_response_transformer_model)

aic_backward_response_transformer_model = lm(log(SalePrice) ~ MSZoning + LotFrontage + LotArea + Street + LandContour + Utilities + LotConfig + LandSlope + Neighborhood + Condition1 + Condition2 + BldgType + HouseStyle + OverallCond + YearRemodAdd + RoofStyle + RoofMatl + Exterior1st + MasVnrType + ExterQual + BsmtQual + BsmtExposure + BsmtFinType1 + HeatingQC + BedroomAbvGr + KitchenQual + FireplaceQu + GarageFinish + GarageQual + GarageCond + PoolQC + SaleType, house_prices_train)
```



> Stepwise Search to selcte the model.
```{r}
build_model_from_stepwise_Search = function(data){
  allpredictors = names(data)
  scope_string = as.formula(paste(response, paste(allpredictors, collapse=" + "), sep=" ~ ")) 
  start_model = lm(log(SalePrice) ~ 1, data)   
  n = nrow(data)
  model = step(start_model, scope = scope_string, direction = "both", k= log(n), trace = 0)
  model   
}

 stepwise_Search_model = build_model_from_stepwise_Search(house_prices_train)
 summary(stepwise_Search_model)
```


> Predictor transformer
```{r}
poly_model = lm(log(SalePrice) ~ OverallQual + Neighborhood + TotRmsAbvGrd + GarageArea + BsmtFinSF1 + 
                    RoofMatl + OverallCond + X1stFlrSF + X2ndFlrSF + YearBuilt + 
                    Condition2 + SaleCondition + BsmtExposure + KitchenAbvGr +  LotArea + 
                    KitchenQual + ScreenPorch + Street +  MSSubClass + PoolQC + 
                    BsmtFinSF2 + BsmtUnfSF + PoolArea + I(LotArea^2) +  I(YearBuilt^2)+ I(GarageArea^2), house_prices_train)

addi_model = lm(SalePrice ~ OverallQual + Neighborhood + TotRmsAbvGrd + GarageArea + BsmtFinSF1 + 
                    RoofMatl + OverallCond + X1stFlrSF + X2ndFlrSF + YearBuilt + 
                    Condition2 + SaleCondition + BsmtExposure + KitchenAbvGr +  LotArea + 
                    KitchenQual + ScreenPorch + Street +  MSSubClass + PoolQC + 
                    BsmtFinSF2 + BsmtUnfSF + PoolArea + I(LotArea^2) +  I(YearBuilt^2)+ I(GarageArea^2), house_prices_train)

```

> Box-Cox transformer
```{r}
#bic_backward_model = lm(log(SalePrice) ~ OverallQual + Neighborhood + TotRmsAbvGrd + GarageArea + BsmtFinSF1 + 
#                    RoofMatl + OverallCond + X1stFlrSF + X2ndFlrSF + YearBuilt + 
#                    Condition2 + SaleCondition + BsmtExposure + KitchenAbvGr +  LotArea + 
#                    KitchenQual + ScreenPorch + Street +  MSSubClass + PoolQC + 
#                    BsmtFinSF2 + BsmtUnfSF + PoolArea, house_prices_train)
                    
boxcox(bic_backward_response_transformer_model, plotit = TRUE)

boxcox(addi_model, plotit = TRUE)



addi_boxcox_model = lm((((SalePrice ^ 0.3) - 1) / 0.3) ~ OverallQual + Neighborhood + TotRmsAbvGrd + GarageArea + BsmtFinSF1 + 
                    RoofMatl + OverallCond + X1stFlrSF + X2ndFlrSF + YearBuilt + 
                    Condition2 + SaleCondition + BsmtExposure + KitchenAbvGr +  LotArea + 
                    KitchenQual + ScreenPorch + Street +  MSSubClass + PoolQC + 
                    BsmtFinSF2 + BsmtUnfSF + PoolArea + I(LotArea^2) +  I(YearBuilt^2)+ I(GarageArea^2), house_prices_train)


poly_boxcox_model = lm(((log(SalePrice)^4.4 - 1) / 4.4) ~ OverallQual + Neighborhood + TotRmsAbvGrd + GarageArea + BsmtFinSF1 + 
                    RoofMatl + OverallCond + X1stFlrSF + X2ndFlrSF + YearBuilt + 
                    Condition2 + SaleCondition + BsmtExposure + KitchenAbvGr +  LotArea + 
                    KitchenQual + ScreenPorch + Street +  MSSubClass + PoolQC + 
                    BsmtFinSF2 + BsmtUnfSF + PoolArea + I(LotArea^2) +  I(YearBuilt^2)+ I(GarageArea^2), house_prices_train)
```





> Let's do some testing for those models.

```{r}
fitted_versus_residuals_plot = function(fit){
  plot(fitted(fit), resid(fit), col = "grey", pch = 20,
     xlab = "Fitted", ylab = "Residuals", main = "Data from Final Model")
  abline(h = 0, col = "darkorange", lwd = 2)
}


QQ_plot = function(fit){
  qqnorm(resid(fit), main = "Normal Q-Q Plot, Final Model", col = "darkgrey")
  qqline(resid(fit), col = "dodgerblue", lwd = 2)
   
}



fit_model_test = function(model, title){
   #par(mfrow = c(1, 2))
   #fitted_versus_residuals_plot(model)
   #QQ_plot(model)
   par(mfrow = c(2, 2))
   plot(model, main = title)
   
   
}
```


```{r}
fit_model_test(additive_model, "Additive Model")
fit_model_test(additive_modified_model, "Additive Modified Model")
fit_model_test(aic_backward_model, "AIC Backward Selected Model")
fit_model_test(bic_backward_model, "BIC Backward Selected Model")
fit_model_test(bic_backward_response_transformer_model, "BIC Response Transformer Model")
fit_model_test(aic_backward_response_transformer_model, "AIC Response Transformer Model")
fit_model_test(stepwise_Search_model, "Stepwise Search Model")
fit_model_test(poly_model, "Poly Predictor transformer")
fit_model_test(addi_model, "Additive Predictor transformer")
fit_model_test(addi_boxcox_model, "additive boxcox model")
fit_model_test(poly_boxcox_model, "Poly boxcox model")
```


```{r}
model_diagnostics = function(model, title){
   print(title)
   print(vif(model))
   print("shapiro.test((resid(model)")  
   print(shapiro.test((resid(model))))
   print("loocv_rmse")
   print(calc_loocv_rmse(model))
   print("AIC")
   print(extractAIC(model))
   print("BIc")
   print(extractAIC(model, k = log(length(resid(model)))))
}
```


```{r}
model_diagnostics(additive_model, "Additive Model")
model_diagnostics(additive_modified_model, "Additive Modified Model")
model_diagnostics(aic_backward_model, "AIC Backward Selected Model")
model_diagnostics(bic_backward_model, "BIC Backward Selected Model")
model_diagnostics(bic_backward_response_transformer_model, "BIC Response Transformer Model")
model_diagnostics(aic_backward_response_transformer_model, "AIC Response Transformer Model")
model_diagnostics(stepwise_Search_model, "Stepwise Search Model")
model_diagnostics(poly_model, "Poly Predictor transformer")
model_diagnostics(addi_model, "Additive Predictor transformer")
model_diagnostics(addi_boxcox_model, "additive boxcox model")
model_diagnostics(poly_boxcox_model, "Poly boxcox model")
```


# Results
The results section should contain numerical or graphical summaries of your results. You should report a final model you have chosen. There is not necessarily one, singular correct model, but certainly some methods and models are better than others in certain situations. You may use any methods we studied this semester to complete this task, and provide evidence that your final choice of model is a good one.






# Discussion
The discussion section should contain discussion of your results and should frame your results in the context of the data. How is your final model useful?


# Appendix
The appendix section should contain code and analysis that is used, but that may clutter the report or is not directly related to the choice of model.






# Something we may use:
- Building the Model 
- Colinearity 
- Removing influential data points
- Transformations
- Alternative models
- Model Comparison
- Model Validation
- AIC/BIC Testing
- LOOCV_RMSE
